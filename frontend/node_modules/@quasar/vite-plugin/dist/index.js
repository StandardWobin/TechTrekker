'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vite = require('vite');
var package_json = require('quasar/package.json');
var autoImportData = require('quasar/dist/transforms/auto-import.json');
var importTransformation = require('quasar/dist/transforms/import-transformation.js');
var loaderAssetUrls_json = require('quasar/dist/transforms/loader-asset-urls.json');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var autoImportData__default = /*#__PURE__*/_interopDefaultLegacy(autoImportData);
var importTransformation__default = /*#__PURE__*/_interopDefaultLegacy(importTransformation);
var loaderAssetUrls_json__default = /*#__PURE__*/_interopDefaultLegacy(loaderAssetUrls_json);

function getViteConfig (runMode, viteMode, externalViteCfg) {
  const viteCfg = {
    define: {
      __QUASAR_VERSION__: `'${ package_json.version }'`,
      __QUASAR_SSR__: false,
      __QUASAR_SSR_SERVER__: false,
      __QUASAR_SSR_CLIENT__: false
    }
  };

  // Set this to the default value only if it's not already set.
  // @quasar/app-vite configures this by itself when it needs it.
  if (!externalViteCfg.define || externalViteCfg.define.__QUASAR_SSR_PWA__ === void 0) {
    viteCfg.define.__QUASAR_SSR_PWA__ = false;
  }

  if (runMode === 'ssr-server') {
    Object.assign(viteCfg.define, {
      __QUASAR_SSR__: true,
      __QUASAR_SSR_SERVER__: true
    });
  }
  else {
    // Alias "quasar" package to its dev file (which has flags)
    // to reduce the number of HTTP requests while in DEV mode
    if (viteMode === 'development') {
      viteCfg.resolve = {
        alias: [
          { find: /^quasar$/, replacement: 'quasar/dist/quasar.esm.js' }
        ]
      };
    }
    else {
      viteCfg.optimizeDeps = {
        exclude: [ 'quasar' ]
      };
    }

    if (runMode === 'ssr-client') {
      Object.assign(viteCfg.define, {
        __QUASAR_SSR__: true,
        __QUASAR_SSR_CLIENT__: true
      });
    }
  }

  return viteCfg
}

const importQuasarRegex = /import\s*\{([\w,\s]+)\}\s*from\s*(['"])quasar\2;?/g;

/**
 * Transforms JS code where importing from 'quasar' package
 * Example:
 *       import { QBtn } from 'quasar'
 *    -> import QBtn from 'quasar/src/components/QBtn.js'
 */
function mapQuasarImports (code, importMap = {}) {
  return code.replace(
    importQuasarRegex,
    (_, match) => match
      .split(',')
      .map(identifier => {
        const data = identifier.split(' as ');
        const importName = data[0].trim();

        // might be an empty entry like below
        // (notice useQuasar is followed by a comma)
        // import { QTable, useQuasar, } from 'quasar'
        if (importName === '') {
          return ''
        }

        const importAs = data[1] !== void 0
          ? data[1].trim()
          : importName;

        importMap[importName] = importAs;
        return `import ${ importAs } from '${ importTransformation__default["default"](importName) }';`
      })
      .join('')
  )
}

/**
 * Transforms JS code where importing from 'quasar' package
 * Example:
 *       import { QBtn } from 'quasar'
 *    -> add to importMap & importList & remove original import statement
 *    (removing original is required so that the end file will have
 *     only one import from Quasar statement)
 */
function removeQuasarImports (code, importMap, importList, reverseMap) {
  return code.replace(
    importQuasarRegex,
    (_, match) => {
      match.split(',').forEach(identifier => {
        const data = identifier.split(' as ');
        const importName = data[0].trim();

        // might be an empty entry like below
        // (notice useQuasar is followed by a comma)
        // import { QTable, useQuasar, } from 'quasar'
        if (importName !== '') {
          const importAs = data[1] !== void 0
            ? data[1].trim()
            : importName;

          importList.push(importName + (importAs !== importName ? ` as ${ importAs }` : ''));
          importMap[importName] = importAs;
          reverseMap[importName.replace(/-/g, '_')] = importAs;
        }
      });

      // we registered the original import and we
      // remove this one to avoid duplicate imports from Quasar
      return ''
    }
  )
}

const compRegex = {
  'kebab': new RegExp(`_resolveComponent\\("${autoImportData__default["default"].regex.kebabComponents}"\\)`, 'g'),
  'pascal': new RegExp(`_resolveComponent\\("${autoImportData__default["default"].regex.pascalComponents}"\\)`, 'g'),
  'combined': new RegExp(`_resolveComponent\\("${autoImportData__default["default"].regex.components}"\\)`, 'g')
};

const dirRegex = new RegExp(`_resolveDirective\\("${autoImportData__default["default"].regex.directives.replace(/v-/g, '')}"\\)`, 'g');
const lengthSortFn = (a, b) => b.length - a.length;

function vueTransform (content, autoImportComponentCase, useTreeshaking) {
  const importList = [];
  const importMap = {};

  const compList = [];
  const dirList = [];

  const reverseMap = {};
  const jsImportTransformed = useTreeshaking === true
    ? mapQuasarImports(content, importMap)
    : removeQuasarImports(content, importMap, importList, reverseMap);

  let code = jsImportTransformed
    .replace(compRegex[autoImportComponentCase], (_, match) => {
      const name = autoImportData__default["default"].importName[match];
      const reverseName = match.replace(/-/g, '_');

      if (importMap[name] === void 0) {
        importList.push( name );
        reverseMap[reverseName] = name;
      }
      else {
        reverseMap[reverseName] = importMap[name];
      }

      compList.push(reverseName);
      return ''
    })
    .replace(dirRegex, (_, match) => {
      const name = autoImportData__default["default"].importName['v-' + match];
      const reverseName = match.replace(/-/g, '_');

      if (importMap[name] === void 0) {
        importList.push( name );
        reverseMap[reverseName] = name;
      }
      else {
        reverseMap[reverseName] = importMap[name];
      }

      dirList.push(reverseName);
      return ''
    });

  if (importList.length === 0) {
    return code
  }

  if (compList.length !== 0) {
    const list = compList.sort(lengthSortFn).join('|');
    code = code
      .replace(new RegExp(`const _component_(${list}) = `, 'g'), '')
      .replace(new RegExp(`_component_(${list})`, 'g'), (_, match) => reverseMap[match]);
  }

  if (dirList.length !== 0) {
    const list = dirList.sort(lengthSortFn).join('|');
    code = code
      .replace(new RegExp(`const _directive_(${list}) = `, 'g'), '')
      .replace(new RegExp(`_directive_(${list})`, 'g'), (_, match) => reverseMap[match]);
  }

  const codePrefix = useTreeshaking === true
    ? importList.map(name => `import ${name} from '${importTransformation__default["default"](name)}'`).join(`;`)
    : `import {${importList.join(',')}} from 'quasar'`;

  return codePrefix + ';' + code
}

function createScssTransform (fileExtension, sassVariables) {
  const sassImportCode = [ `@import 'quasar/src/css/variables.sass'`, '' ];

  if (typeof sassVariables === 'string') {
    sassImportCode.unshift(`@import '${ sassVariables }'`);
  }

  const prefix = fileExtension === 'sass'
    ? sassImportCode.join('\n')
    : sassImportCode.join(';\n');

  return content => {
    let useIndex = Math.max(
      content.lastIndexOf('@use '),
      content.lastIndexOf('@forward ')
    );

    if (useIndex === -1) {
      return prefix + content
    }

    const newLineIndex = content.indexOf('\n', useIndex);
    
    if (newLineIndex !== -1) {
      const index = newLineIndex + 1;
      return content.substring(0, index) + prefix + content.substring(index)
    }

    return content + '\n' + prefix
  }
}

/**
 * @typedef {{
 *  vue: () => boolean;
 *  template: () => boolean;
 *  script: (extensions?: string | string[]) => boolean;
 *  style: (extensions?: string | string[]) => boolean;
 * }} ViteQueryIs
 */

/**
 * @see https://github.com/vitejs/vite/blob/364aae13f0826169e8b1c5db41ac6b5bb2756958/packages/plugin-vue/src/utils/query.ts - source of inspiration
 * @example
 * '/absolute/path/src/App.vue' // Can contain combined template&script -> template: true, script: true, style: false
 * '/absolute/path/src/App.vue?vue&type=script&lang.js' // Only contains script -> template: false, script: true, style: false
 * '/absolute/path/src/App.vue?vue&type=style&lang.sass' // Only contains style -> template: false, script: false, style: true
 * '/absolute/path/src/script.js' // Only contains script -> template: false, script: true, style: false
 * '/absolute/path/src/index.scss' // Only contains style -> template: false, script: false, style: true
 *
 * @param {string} id
 * @returns {{ filename: string; query: { [key: string]: string; }; is: ViteQueryIs }}
 */
function parseViteRequest (id) {
  const [ filename, rawQuery ] = id.split('?', 2);
  const query = Object.fromEntries(new URLSearchParams(rawQuery));

  const is = query.vue !== void 0 // is vue query?
    ? {
        // Almost all code might get merged into a single request with no 'type' (App.vue?vue)
        // or stay with their original 'type's (App.vue?vue&type=script&lang.ts)
        vue: () => true,
        template: () =>
          query.type === void 0 ||
          query.type === 'template' ||
          // On prod, TS code turns into a separate 'script' request.
          // See: https://github.com/vitejs/vite/pull/7909
          (query.type === 'script' && (query['lang.ts'] !== void 0 || query['lang.tsx'] !== void 0)),
        script: (extensions = scriptExt) =>
          (query.type === void 0 || query.type === 'script') &&
          isOfExt({ query, extensions }) === true,
        style: (extensions = styleExt) =>
          query.type === 'style' && isOfExt({ query, extensions }) === true
      }
    : {
        vue: () => isOfExt({ extensions: vueExt, filename }),
        template: () => isOfExt({ filename, extensions: vueExt }),
        script: (extensions = scriptExt) => isOfExt({ filename, extensions }),
        style: (extensions = styleExt) => isOfExt({ filename, extensions })
      };

  return {
    filename,
    query,
    is
  }
}

const vueExt = [ '.vue' ];
const scriptExt = [ '.js', '.jsx', '.ts', '.tsx', '.vue' ];
const styleExt = [ '.css', '.scss', '.module.scss', '.sass', '.module.sass' ];

const isOfExt = ({ extensions, filename, query }) =>
  extensions.some(
    ext => filename?.endsWith(ext) || query?.[`lang${ext}`] !== void 0
  );

const defaultOptions = {
  runMode: 'web-client',
  autoImportComponentCase: 'kebab',
  sassVariables: true,
  devTreeshaking: false
};

function getConfigPlugin (opts) {
  return {
    name: 'vite:quasar:vite-conf',

    configResolved (viteConf) {
      const vueCfg = viteConf.plugins.find(entry => entry.name === 'vite:vue');

      if (vueCfg === void 0) {
        console.error('\n\n[Quasar] Error: In your Vite config file, please add the Quasar plugin ** after ** the Vue one\n\n');
        process.exit(1);
      }
    },

    config (viteConf, { mode }) {
      return getViteConfig(opts.runMode, mode, viteConf)
    }
  }
}

function getScssTransformsPlugin (opts) {
  const sassVariables = typeof opts.sassVariables === 'string'
    ? vite.normalizePath(opts.sassVariables)
    : opts.sassVariables;

  const scssTransform = createScssTransform('scss', sassVariables);
  const sassTransform = createScssTransform('sass', sassVariables);
  const scssExt = [ '.scss', '.module.scss' ];
  const sassExt = [ '.sass', '.module.sass' ];

  return {
    name: 'vite:quasar:scss',

    enforce: 'pre',

    transform (src, id) {
      const { is } = parseViteRequest(id);

      if (is.style(scssExt) === true) {
        return {
          code: scssTransform(src),
          map: null
        }
      }

      if (is.style(sassExt) === true) {
        return {
          code: sassTransform(src),
          map: null
        }
      }

      return null
    }
  }
}

function getScriptTransformsPlugin (opts) {
  let useTreeshaking = true;

  return {
    name: 'vite:quasar:script',

    configResolved (resolvedConfig) {
      if (opts.devTreeshaking === false && resolvedConfig.mode === 'development') {
        useTreeshaking = false;
      }
    },

    transform (src, id) {
      const { is } = parseViteRequest(id);

      if (is.template() === true) {
        return {
          code: vueTransform(src, opts.autoImportComponentCase, useTreeshaking),
          map: null // provide source map if available
        }
      }

      if (useTreeshaking === true && is.script() === true) {
        return {
          code: mapQuasarImports(src),
          map: null // provide source map if available
        }
      }

      return null
    }
  }
}

function plugin (userOpts = {}) {
  const opts = {
    ...defaultOptions,
    ...userOpts
  };

  const plugins = [
    getConfigPlugin(opts)
  ];

  if (opts.sassVariables) {
    plugins.push(
      getScssTransformsPlugin(opts)
    );
  }

  if (opts.runMode !== 'ssr-server') {
    plugins.push(
      getScriptTransformsPlugin(opts)
    );
  }

  return plugins
}

Object.defineProperty(exports, 'transformAssetUrls', {
  enumerable: true,
  get: function () { return loaderAssetUrls_json__default["default"]; }
});
exports.quasar = plugin;
